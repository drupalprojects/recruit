<?php
// $Id$

/**
 * Returns an initialized job type object.
 */
function recruit_job_type_new() {
  return (object) array(
    'type' => '',
    'name' => '',
    'description' => '',
    'help' => '',
  );
}

/**
 * Returns an array of job type objects keyed by type.
 */
function recruit_job_types() {
  // First check the static cache for a job types array.
  $jobs_types = &drupal_static(__FUNCTION__);

  // If it did not exist, fetch the types now.
  if (!isset($job_types)) {
    $job_types = db_query('SELECT * FROM {recruit_job_type}')->fetchAllAssoc('type');
  }

  return $job_types;
}

/**
 * Saves a job type.
 *
 * This function will either insert a new job type if $job_type->is_new
 * is set or attempt to update an existing job type if it is not. It does
 * not currently support changing the machine-readable name of the job type,
 * nor is this possible through the form supplied by the Job UI module.
 *
 * @param $job_type
 *   The job type object containing the basic properties as initialized in
 *     recruit_job_type_new().
 *
 * @return
 *   The return value of the call to drupal_write_record() to save the job
 *     type, either FALSE on failure or SAVED_NEW or SAVED_UPDATED indicating
 *     the type of query performed to save the job type.
 */
function recruit_job_type_save($job_type) {
  $op = drupal_write_record('recruit_job_type', $job_type, empty($job_type->is_new) ? 'type' : array());
  menu_rebuild();

  // If this is a new job type and the insert did not fail...
  if (!empty($job_type->is_new) && $op !== FALSE) {
    // Notify the field API that a new bundle has been created.
    field_attach_create_bundle('recruit_job', $job_type->type);

    // Notify other modules that a new job type has been created.
    module_invoke_all('recruit_job_type_insert', $job_type);
  }
  else {
    // Notify other modules that an existing job type has been updated.
    module_invoke_all('recruit_job_type_update', $job_type);
  }

  return $op;
}

/**
 * Implements hook_recruit_job_type_load().
 */
function recruit_job_recruit_job_type_load($job_type) {
  if (!empty ($job_type->type)) {
    //Get job type expiry settings.
    recruit_job_job_type_expiry_load($job_type);
  }
}

/**
 * Implements hook_recruit_job_type_insert().
 */
function recruit_job_recruit_job_type_insert($job_type) {
  if (!empty ($job_type->type)) {
    //Update job type expiry settings.
    recruit_job_job_type_expiry_update($job_type);
  }
}

/**
 * Implements hook_recruit_job_type_update().
 */
function recruit_job_recruit_job_type_update($job_type) {
  if (!empty ($job_type->type)) {
    //Update job type expiry settings.
    recruit_job_job_type_expiry_update($job_type);
  }
}

/**
 * Implements hook_recruit_job_type_delete().
 */
function recruit_job_recruit_job_type_delete($job_type) {
  //Update job type expiry settings.
  recruit_job_job_type_expiry_delete($job_type);
}

function recruit_job_job_type_expiry_load($job_type) {
  $job_type->expiry['expiry'] = variable_get('recruit_job_expiry_' . $job_type->type);
  $job_type->expiry['days'] = variable_get('recruit_job_expiry_days_' . $job_type->type);
}

function recruit_job_job_type_expiry_update($job_type) {
  
  if ($job_type->expiry['expiry']) {
    variable_set('recruit_job_expiry_' . $job_type->type, 1);

    $days = $job_type->expiry['days'];
    if ($days > 0) {
      variable_set('recruit_job_expiry_days_' . $job_type->type, $days);
    }
    else {
      variable_del('recruit_job_expiry_days_' . $job_type->type);
    }
  }
  else {
    variable_del('recruit_job_expiry_days_' . $job_type->type);
    variable_set('recruit_job_expiry_' . $job_type->type, 0);
  }
  
}

function recruit_job_job_type_expiry_delete($job_type) {
  variable_del('recruit_job_expiry_days_' . $job_type->type);
  variable_del('recruit_job_expiry_' . $job_type->type, 0);
}
/**
 * Checks job access for various operations.
 *
 * @param $op
 *   The operation being performed. One of 'view', 'update', 'create' or
 *   'delete'.
 * @param $job
 *   Optionally a job to check access for or for the create operation the
 *   job type. If nothing is given access permissions for all jobs are returned.
 * @param $account
 *   The user to check for. Leave it to NULL to check for the current user.
 */
function recruit_job_access($op, $job = NULL, $account = NULL) {
  global $user;
  $account = isset($account) ? $account : $user;

  if (user_access('administer jobs', $account)) {
    return TRUE;
  }

  if ($op == 'view' && user_access('access jobs', $account)) {
    return TRUE;
  }

  if (isset($job) && is_string($job) && $op == 'create' && user_access('create ' . $job . ' jobs', $account)) {
    return TRUE;
  }

  if (isset($job) && ($op == 'update' || $op == 'delete')) {
    if (user_access('edit any ' . $job->type . ' job', $account)) {
      return TRUE;
    }

    // Others either don't have any access or must match the job uid.
    if ($account->uid && user_access('edit own ' . $job->type . ' jobs', $account) && $job->uid == $account->uid) {
      return TRUE;
    }
  }

  return FALSE;
}

/**
 * Returns an initialized job object.
 *
 * @param $type
 *   The machine-readable type of the job.
 *
 * @return
 *   A job object with all default fields initialized.
 */
function recruit_job_new($type = '') {
  return entity_get_controller('recruit_job')->create($type);
}

/**
 * Implements hook_views_api().
 */
function recruit_job_views_api() {
  return array(
    'api' => 2,
    'path' => drupal_get_path('module', 'recruit_job') . '/includes/views',
  );
}

/**
 * Implements hook_permission().
 */
function recruit_job_permission() {
  $permissions = array(
    'administer jobs' => array(
      'title' => t('Administer jobs'),
      'description' => t('Allows users to perform any action on jobs of any type.'),
      'restrict access' => TRUE,
    ),
    'administer job types' => array(
      'title' => t('Administer job types'),
      'description' => t('Allows users to add job types and configure their fields.'),
      'restrict access' => TRUE,
    ),
    'access jobs' => array(
      'title' => t('Access jobs'),
      'description' => t('Allows users to view lists of jobs in the Recruiter admin and reference lists.'),
    ),
  );

  // Add job type specific permissions. Note that users with administer
  // jobs permission should have access to do anything the permissions below
  // grant a user to do.
  foreach (recruit_job_type_get_name() as $type => $name) {
    $permissions['create ' . $type . ' jobs'] = array(
      'title' => t('Create %type jobs', array('%type' => $name)),
    );
    $permissions['edit any ' . $type . ' job'] = array(
      'title' => t('Edit or delete any %type job', array('%type' => $name)),
    );
    $permissions['edit own ' . $type . ' jobs'] = array(
      'title' => t('Edit or delete own %type jobs', array('%type' => $name)),
    );
  }

  return $permissions;
}

/**
 * Returns the human readable name of any or all job types.
 *
 * @param $type
 *   Optional parameter specifying the type whose name to return.
 *
 * @return
 *   Either an array of all job type names keyed by the machine name or a
 *     string containing the human readable name for the specified type. If a
 *     type is specified that does not exist, this function returns FALSE.
 */
function recruit_job_type_get_name($type = NULL) {
  $job_types = recruit_job_types();

  // Return a type name if specified and it exists.
  if (!empty($type)) {
    if (isset($job_types[$type])) {
      return $job_types[$type]->name;
    }
    else {
      // Return FALSE if it does not exist.
      return FALSE;
    }
  }

  // Otherwise turn the array values into the type name only.
  foreach ($job_types as $key => $value) {
    $job_types[$key] = $value->name;
  }

  return $job_types;
}

/**
 * Implements hook_entity_info().
 */
function recruit_job_entity_info() {
  $return = array(
    'recruit_job' => array(
      'label' => t('Job'),
      'controller class' => 'RecruitJobEntityController',
      'base table' => 'recruit_job',
      'fieldable' => TRUE,
      'entity keys' => array(
        'id' => 'job_id',
        'bundle' => 'type',
      ),
      'bundle keys' => array(
        'bundle' => 'type',
      ),
      'bundles' => array(),
      'load hook' => 'recruit_job_load',
      'view modes' => array(
        'full' => array(
          'label' => t('Admin display'),
          'custom settings' => FALSE,
        ),
        'job_teaser' => array(
          'label' => t('Job: Teaser'),
          'custom settings' => TRUE,
        ),
        'job_full' => array(
          'label' => t('Job: Full content'),
          'custom settings' => FALSE,
        ),
        'job_rss' => array(
          'label' => t('Job: RSS'),
          'custom settings' => FALSE,
        ),
      ),
      'creation callback' => '_recruit_job_create',
      'save callback' => 'recruit_job_save',
      'deletion callback' => 'recruit_job_delete',
      'access callback' => 'recruit_job_access',
    ),
  );

  foreach (recruit_job_type_get_name() as $type => $name) {
    $return['recruit_job']['bundles'][$type] = array(
      'label' => $name,
    );
  }

  return $return;
}

/**
 * Implements hook_field_extra_fields().
 */
function recruit_job_field_extra_fields() {
  $extra = array();

  foreach (recruit_job_types() as $type => $job_type) {
    $extra['recruit_job'][$type] = array(
      'form' => array(
        'job_ref' => array(
          'label' => 'Job Reference',
          'description' => t('Job module job reference form element'),
          'weight' => -10,
        ),
        'title' => array(
          'label' => 'Title',
          'description' => t('Job module title form element'),
          'weight' => -5,
        ),
        'status' => array(
          'label' => 'Status',
          'description' => t('Job module status form element'),
          'weight' => 35,
        ),
      ),
      'display' => array(
        'job_ref' => array(
          'label' => 'Job Reference',
          'description' => t('The human readable identifier of the job'),
          'weight' => -10,
        ),
        'title' => array(
          'label' => 'Title',
          'description' => t('Full job title'),
          'weight' => -5,
        ),
      ),
    );
  }

  return $extra;
}

/**
 * Loads a job by ID.
 */
function recruit_job_load($job_id) {
  $jobs = recruit_job_load_multiple(array($job_id), array());
  return $jobs ? reset($jobs) : FALSE;
}

/**
 * Loads multiple jobs by ID or based on a set of matching conditions.
 *
 * @see entity_load()
 *
 * @param $jobs_ids
 *   An array of job IDs.
 * @param $conditions
 *   An array of conditions on the {recruit_job} table in the form
 *     'field' => $value.
 * @param $reset
 *   Whether to reset the internal job loading cache.
 *
 * @return
 *   An array of job objects indexed by job_id.
 */
function recruit_job_load_multiple($jobs_ids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load('recruit_job', $jobs_ids, $conditions, $reset);
}

/**
 * Creation callback for the Entity Metadata module.
 */
function _recruit_job_create($values = array()) {
  // Create a new job of the specified type.
  $job = recruit_job_new($values['type']);
  unset($values['type']);

  $wrapper = entity_metadata_wrapper('recruit_job', $job);

  foreach ($values as $name => $value) {
    $wrapper->$name->set($value);
  }

  return $wrapper;
}

/**
 * Saves a job.
 *
 * @param $job
 *   The full job object to save.
 *
 * @return
 *   TRUE on success, FALSE otherwise.
 */
function recruit_job_save($job) {
  return entity_get_controller('recruit_job')->save($job);
}

/**
 * Deletes a job by ID.
 *
 * @param $job_id
 *   The ID of the job to delete.
 *
 * @return
 *   TRUE on success, FALSE otherwise.
 */
function recruit_job_delete($job_id) {
  return recruit_job_delete_multiple(array($job_id));
}

/**
 * Deletes multiple jobs by ID.
 *
 * @param $job_ids
 *   An array of job IDs to delete.
 *
 * @return
 *   TRUE on success, FALSE otherwise.
 */
function recruit_job_delete_multiple($job_ids) {
  return entity_get_controller('recruit_job')->delete($job_ids);
}

/**
 * Callback for getting job properties.
 * @see recruit_job_entity_property_info()
 */
function recruit_job_get_properties($job, array $options, $name) {
  switch ($name) {
    case 'creator':
      return $job->uid;
    case 'edit-url':
      return url('admin/recruit/jobs/' . $job->job_id . '/edit', $options);
  }
}

/**
 * Callback for setting job properties.
 * @see recruit_job_entity_property_info()
 */
function recruit_job_set_properties($job, $name, $value) {
  if ($name == 'creator') {
    $job->uid = $value;
  }
}

/**
 * Validates a Job Reference string for acceptable characters.
 *
 * @param $job_ref
 *   The Job Reference string to validate.
 *
 * @return
 *   TRUE or FALSE indicating whether or not the Job Reference contains valid characters.
 */
function recruit_job_validate_job_ref_characters($job_ref) {
  return preg_match('!^[A-Za-z0-9_-]+$!', $job_ref);
}

/**
 * Checks to see if a given job reference already exists for another job.
 *
 * @param $job_ref
 *   The string to match against existing job references.
 * @param $job_id
 *   The ID of the job the job reference is for; an empty value represents the job reference is
 *     meant for a new job.
 *
 * @return
 *   TRUE or FALSE indicating whether or not the job reference exists for another job.
 */
function recruit_job_validate_job_ref_unique($job_ref, $job_id) {
  // Look for an ID of a job matching the supplied SKU.
  if ($match_id = db_query('SELECT job_id FROM {recruit_job} WHERE job_ref = :job_ref', array(':job_ref' => $job_ref))->fetchField()) {
    // If this SKU is supposed to be for a new job or a job other than
    // the one that matched...
    if (empty($job_id) || $match_id != $job_id) {
      return FALSE;
    }
  }

  return TRUE;
}

/**
 * Checks to see if a given job type already exists.
 *
 * @param $type
 *   The string to match against existing types.
 *
 * @return
 *   TRUE or FALSE indicating whether or not the job type exists.
 */
function recruit_job_type_validate_type_unique($type) {
  // Look for a match of the type.
  if ($match_id = db_query('SELECT type FROM {recruit_job_type} WHERE type = :type', array(':type' => $type))->fetchField()) {
    return FALSE;
  }

  return TRUE;
}

/**
 * Loads a job type.
 *
 * @param $type
 *   The machine-readable name of the job type.
 */
function recruit_job_type_load($type) {
  $job_type = db_query('SELECT * FROM {recruit_job_type} WHERE type = :type', array(':type' => $type))->fetchObject();
  module_invoke_all('recruit_job_type_load', $job_type);
  return $job_type;
}

/**
 * Deletes a job type.
 *
 * @param $type
 *   The machine-readable name of the job type.
 */
function recruit_job_type_delete($type) {
  $job_type = recruit_job_type_load($type);

  db_delete('recruit_job_type')
    ->condition('type', $type)
    ->execute();

  // Rebuild the menu to get rid of this type's job add menu item.
  menu_rebuild();

  // Notify the field API that this bundle has been destroyed.
  field_attach_delete_bundle('recruit_job', $type);

  // Notify other modules that this job type has been deleted.
  module_invoke_all('recruit_job_type_delete', $job_type);
}

/**
 * Title callback: return the human-readable job type name.
 */
function recruit_job_type_title($job_type) {
  return $job_type->name;
}

/**
 * Returns a path argument from a job type.
 */
function recruit_job_type_to_arg($type) {
  return $type;
}

/**
 * Handler to load the unchanged job variable for rules.
 * @see recruit_job_rules_variables().
 */
function recruit_job_rules_var_unchanged($job) {
  $unchanged = drupal_static('recruit_job_unchanged');
  if (isset($job->job_id) && isset($unchanged[$job->job_id])) {
    return $unchanged[$job->job_id];
  }
}

/**
 * Resets the cached list of job types.
 */
function recruit_job_types_reset() {
  $job_types = &drupal_static('recruit_job_types');
  $job_types = NULL;
}

/**
 * Loads a job by job reference.
 */
function recruit_job_load_by_job_ref($job_ref) {
  $jobs = recruit_job_load_multiple(array(), array('job_ref' => $job_ref));
  return $jobs ? reset($jobs) : FALSE;
}

/**
 * Implements hook_pathauto().
 */
function recruit_job_pathauto($op) {
  switch ($op) {
    case 'settings':
      $settings = array();
      $settings['module'] = 'recruit_job';
      $settings['token_type'] = 'job';
      $settings['groupheader'] = t('Job paths');
      $settings['patterndescr'] = t('Default path pattern (applies to all job types with blank patterns below)');
      $settings['patterndefault'] = 'job/[job:title]';
      $settings['batch_update_callback'] = 'recruit_job_pathauto_bulk_update_batch_process';
      #$settings['batch_file'] = drupal_get_path('module', 'pathauto') . '/pathauto.pathauto.inc';

      $languages = array();
      if (module_exists('locale')) {
        $languages = array(LANGUAGE_NONE => t('language neutral')) + locale_language_list('name');
      }

      foreach (recruit_job_types() as $job_type) {
        if (count($languages) && variable_get('language_content_type_' . $job_type->type, 0)) {
          $settings['patternitems'][$job_type->type] = t('Default path pattern for @node_type (applies to all @job_type node types with blank patterns below)', array('@job_type' => $job_type->name));
          foreach ($languages as $lang_code => $lang_name) {
            $settings['patternitems'][$job_type->type . '_' . $lang_code] = t('Pattern for all @language @job_type paths', array('@job_type' => $job_type->name, '@language' => $lang_name));
          }
        }
        else {
          $settings['patternitems'][$job_type->type] = t('Pattern for all @job_type paths', array('@job_type' => $job_type->name));
        }
      }


      return (object) $settings;
    default:
      break;
  }
}

/**
 * Implements hook_recruit_job_insert().
 */
function recruit_job_recruit_job_insert($job) {
  #if (!isset($node->path['pathauto_perform_alias']) || !empty($node->path['pathauto_perform_alias'])) {
  if (module_exists('pathauto')) {
    recruit_job_job_update_alias($job, 'insert');
  }
  #}
}

/**
 * Implements hook_recruit_job_update().
 */
function recruit_job_recruit_job_update($job) {
  #if (!isset($node->path['pathauto_perform_alias']) || !empty($node->path['pathauto_perform_alias'])) {
  if (module_exists('pathauto')) {
    recruit_job_job_update_alias($job, 'update');
  }
  #dsm($job);
  
  #}
}

/**
 * Implements hook_recruit_job_delete().
 */
function recruit_job_recruit_job_delete($job) {
  if (module_exists('pathauto')) {
    //Get job uri.
    $uri = entity_uri('recruit_job', $job);
    pathauto_entity_path_delete_all('recruit_job', $job, $uri['path']);
  }
}

/**
 * Update the URL aliases for an individual job.
 *
 * @param $job
 *   A job object.
 * @param $op
 *   Operation being performed on the job ('insert', 'update' or 'bulkupdate').
 * @param $options
 *   An optional array of additional options.
 */
function recruit_job_job_update_alias(stdClass $job, $op, array $options = array()) {
  // Skip processing if the term has no pattern.
  $language = isset($job->language) ? $job->language : LANGUAGE_NONE;
  if (!pathauto_pattern_load_by_entity('recruit_job', $job->type, $language)) {
    return;
  }

  module_load_include('inc', 'pathauto');
  $uri = entity_uri('recruit_job', $job);

  pathauto_create_alias('recruit_job', $op, $uri['path'], array('job' => $job), $job->type, $language);
}

/**
 * Implements hook_path_alias_types().
 *
 * Used primarily by the bulk delete form.
 */
function recruit_job_path_alias_types() {
  $objects['admin/recruit/jobs/'] = t('Jobs');
  return $objects;
}

/**
 * Batch processing callback; Generate aliases for jobs.
 */
function recruit_job_pathauto_bulk_update_batch_process(&$context) {
  if (!isset($context['sandbox']['current'])) {
    $context['sandbox']['count'] = 0;
    $context['sandbox']['current'] = 0;
  }

  $query = db_select('recruit_job', 'j');
  $concat = _pathauto_sql_concat("'admin/recruit/jobs/'", 'j.job_id');
  $query->leftJoin('url_alias', 'ua', "$concat = ua.source");
  $query->addField('j', 'job_id');
  $query->isNull('ua.source');
  $query->condition('j.job_id', $context['sandbox']['current'], '>');
  $query->orderBy('j.job_id');
  $query->addTag('pathauto_bulk_update');
  $query->addMetaData('entity', 'recruit_job');

  // Get the total amount of items to process.
  if (!isset($context['sandbox']['total'])) {
    $context['sandbox']['total'] = $query->countQuery()->execute()->fetchField();

    // If there are no nodes to update, the stop immediately.
    if (!$context['sandbox']['total']) {
      $context['finished'] = 1;
      return;
    }
  }

  $query->range(0, 25);
  $job_ids = $query->execute()->fetchCol();

  recruit_job_job_update_alias_multiple($job_ids, 'bulkupdate');
  $context['sandbox']['count'] += count($job_ids);
  $context['sandbox']['current'] = max($job_ids);
  $context['message'] = t('Updated alias for node @job_id.', array('@job_id' => end($job_ids)));

  if ($context['sandbox']['count'] != $context['sandbox']['total']) {
    $context['finished'] = $context['sandbox']['count'] / $context['sandbox']['total'];
  }
}

/**
 * Update the URL aliases for multiple jobs.
 *
 * @param $job_ids
 *   An array of job IDs.
 * @param $op
 *   Operation being performed on the jobs ('insert', 'update' or
 *   'bulkupdate').
 * @param $options
 *   An optional array of additional options.
 */
function recruit_job_job_update_alias_multiple(array $job_ids, $op, array $options = array()) {
  $options += array('message' => FALSE);

  $jobs = recruit_job_load_multiple($job_ids);
  foreach ($jobs as $job) {
    recruit_job_job_update_alias($job, $op, $options);
  }

  if (!empty($options['message'])) {
    drupal_set_message(format_plural(count($job_ids), 'Updated URL alias for 1 job.', 'Updated URL aliases for @count jobs.'));
  }
}

/**
 * Converts unix timestamp to an array used on the expiry field.
 * Timestamp 1323583200 to
 * array('year' => $year, 'month' => $month, 'day' => $day);
 *
 * @param $timestamp
 *   Unix timestamp.
 */
function recruit_job_convert_timestamp_to_array($timestamp) {
  if ($timestamp) {
    $day = date('j', $timestamp);
    $month = date('n', $timestamp);
    $year = date('Y', $timestamp);

    return array('year' => $year, 'month' => $month, 'day' => $day);
  }
}

/**
 * Converts date field array used on the expiry field
 * to a timestamp.
 * Timestamp 1323583200 to
 * array('year' => $year, 'month' => $month, 'day' => $day);
 *
 * @param $timestamp
 *   Unix timestamp.
 */
function recruit_job_convert_array_to_timestamp($array) {
  if (is_array($array)) {
    
    $day = $array['day'];
    $month = $array['month'];
    $year = $array['year'];

    $expiry_date = mktime(0, 0, 0, $month, $day, $year);
    return $expiry_date;
  }
}

function recruit_job_get_default_expiry_timestamp($job) {
    $expiry_set = variable_get('recruit_job_expiry_' . $job->type);
    $expiry_default = variable_get('recruit_job_expiry_days_' . $job->type);

    if ($expiry_set && $expiry_default) {
      //Convert days to seconds.
      $days_seconds = $expiry_default * 86400;

      //Now + expiry = expiry date.
      $expiry_date = REQUEST_TIME + $days_seconds;

      return recruit_job_convert_timestamp_to_array($expiry_date);
    }
}

/**
 * Implements hook_recruit_job_cron().
 */
function recruit_job_cron() {
  recruit_job_expire_jobs();
}


/**
 * Expires old jobs, this function is usually called from recruit_job_cron.
 */
function recruit_job_expire_jobs() {
  
  //Get jobs where expiry date is < now.
  $result = db_query("SELECT job_id FROM {recruit_job} WHERE expiry < :request_time", array(':request_time' => REQUEST_TIME));

  foreach ($result as $job_id) {
    $job = recruit_job_load($job_id->job_id);

    //disable job.
    $job->status = 0;
    
    //Set watchdog log.
    watchdog('recruit_job', 'Job Ref: !job_ref has expired', array('!job_ref' => $job->job_ref));

    //Save job.
    recruit_job_save($job);
    
    module_invoke_all('recruit_job_expiry', $job);
  }
}