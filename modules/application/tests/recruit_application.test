<?php
// $Id$

/**
 * @file
 * Unit tests for the application module.
 */

/**
 * Test the application and application type CRUD.
 */
class RecruitApplicationCRUDTestCase extends DrupalWebTestCase {
  public static function getInfo() {
    return array(
      'name' => 'Recruit application CRUD',
      'description' => 'Tests the application CRUD functions.',
      'group' => 'Recruit',
    );
  }

  function setUp() {
    parent::setUp('recruit_application');
  }

  /**
   * Ensure the default application types are created.
   */
  function testRecruitApplicationDefaultapplications() {
    $default_types = array(
      'application' => 'application',
    );

    // Load the default application types.
    $types_created = recruit_application_types();

    // Ensure each type exists.
    foreach ($default_types as $type => $name) {
      $this->assertTrue(!empty($types_created[$type]), 'application type ' . check_plain($type) . ' has been created.');
    }
  }

  /**
   * Test the application type CRUD functions.
   */
  function testRecruitApplicationTypeCrud() {
    // Ensure recruit_application_type_new() returns a valid empty application type.
    $new_application_type = recruit_application_type_new();
    $this->assertNotNull($new_application_type->type, 'recruit_application_type_new() instantiated the type property.');
    $this->assertNotNull($new_application_type->name, 'recruit_application_type_new() instantiated the name property.');
    $this->assertNotNull($new_application_type->description, 'recruit_application_type_new() instantiated the description property.');
    $this->assertNotNull($new_application_type->help, 'recruit_application_type_new() instantiated the help property');

    // Supply customer values for the application type properties.
    $type = $this->randomName(20);
    $name = $this->randomName(40);
    $description = $this->randomString(128);
    $help = $this->randomString(128);

    // Add the values to the new content type.
    $new_application_type->type = $type;
    $new_application_type->name = $name;
    $new_application_type->description = $description;
    $new_application_type->help = $help;
    $new_application_type->is_new = TRUE;

    // Ensure recruit_application_type_new() returns the proper value when inserting.
    $return = recruit_application_type_save($new_application_type);
    $this->assertEqual($return, SAVED_NEW, 'recruit_application_type_save() returned SAVED_NEW when saving a new application type.');

    // Load the newly saved content type.
    $saved_application_type = recruit_application_type_load($type);

    // Ensure the values that were saved match the values that we created.
    $this->assertTrue($saved_application_type, 'recruit_application_type_load() loaded the new application type.');
    $this->assertEqual($type, $saved_application_type->type, 'The new application type type was properly saved and loaded.');
    $this->assertEqual($name, $saved_application_type->name, 'The new application type name was properly saved and loaded.');
    $this->assertEqual($description, $saved_application_type->description, 'The new application type description text was properly saved and loaded.');
    $this->assertEqual($help, $saved_application_type->help, 'The new application type help text was properly saved and loaded.');

    // Alter the title, to ensure the update function works.
    $altered_name = $this->randomName(40);
    $saved_application_type->name = $altered_name;

    // Ensure recruit_application_type_save() returns the proper value when updating.
    $return = recruit_application_type_save($saved_application_type);
    $this->assertEqual($return, SAVED_UPDATED, 'recruit_application_type_save() returned SAVED_UPDATED when saving an updated application type.');

    // Reset the cached application types, and verify recruit_application_types load the saved type.
    recruit_application_types_reset();
    $types = recruit_application_types();
    $this->assertNotNull($types[$type], 'recruit_application_types_reset() successfully reset the application types.');
    $this->assertEqual($saved_application_type->name, $altered_name, 'recruit_application_type_save() successfully updated the application type name.');

    // Ensure recruit_application_type_delete() deletes a content type.
    recruit_application_type_delete($type);
    $deleted_type = recruit_application_type_load($type);
    $this->assertFalse($deleted_type, 'recruit_application_type_delete() successfully removed a application type.');
  }

  /**
   * Test the application CRUD functions.
   */
  function testRecruitApplicationCrud() {
    // Ensure recruit_application_new() returns a new application.
    $new_application = recruit_application_new('application');
    $fields = array('application_id', 'application_ref', 'type', 'title', 'uid');
    foreach ($fields as $field) {
      $this->assertNotNull($new_application->{$field}, 'recruit_application_new() instantiated the ' . check_plain($field) . ' property.');
    }

    $new_application->application_ref = $sku = $this->randomName(10);
    $new_application->type = $type = 'application';
    $new_application->title = $title = $this->randomName(10);
    $new_application->uid = $uid = 1;

    // Ensure recruit_application_save() returns TRUE when saving a new application
    $return = recruit_application_save($new_application);
    $this->assertNotEqual($return, FALSE, 'recruit_application_save() successfully saved the new application.');

    // Ensure recruit_application_load() loaded the saved application.
    $loaded_application = recruit_application_load($new_application->application_id);
    foreach ($fields as $field) {
      $this->assertEqual($loaded_application->{$field}, $new_application->{$field}, 'The ' . check_plain($field) . ' value loaded by recruit_application_load() matches the value saved by recruit_application_save()');
    }

    $this->assertTrue($loaded_application->created > 0, 'recruit_application_save() added a created date to the application');
    $this->assertTrue($loaded_application->changed > 0, 'recruit_application_save() added a changed date to the application');

    // Ensure recruit_application_load_by_application_ref() can load a application by application reference.
    $loaded_application_by_application_ref = recruit_application_load_by_application_ref($sku);
    $this->assertEqual($loaded_application_by_application_ref->application_id, $new_application->application_id, 'The ID of the application loaded via recruit_application_load_by_application_ref() matches the saved application ID.');

    // Ensure recruit_application_load_multiple() can load multiple applications.
    $saved_application_ids = array();

    // First create and save multiple new applications.
    for ($i = 0; $i < 3; $i++) {
      $application = recruit_application_new('application');
      $application->type = 'application';
      $application->application_ref = $this->randomName(10);
      $application->title = $this->randomName(10);
      $application->uid = 1;
      recruit_application_save($application);

      // Save the ID and title of the newly created application.
      $saved_applications[$application->application_id] = $application->title;
    }

    $loaded_applications = recruit_application_load_multiple(array_keys($saved_applications));
    $this->assertEqual(count($saved_applications), count($loaded_applications), 'recruit_application_load_multiple() loaded the proper number of the applications.');
    foreach ($loaded_applications as $loaded_application) {
      $this->assertEqual($loaded_application->title, $saved_applications[$loaded_application->application_id], 'recruit_application_load_multiple() successfully loaded a application.');
    }

    // Ensure recruit_application_delete() can remove a application.
    $return = recruit_application_delete($new_application->application_id);
    $this->assertTrue($return, 'recruit_application_delete() returned TRUE when deleting a application.');
    $deleted_application_load = recruit_application_load_multiple(array($new_application->application_id), array(), TRUE);
    $this->assertFalse($deleted_application_load, 'recruit_application_load_multiple() could not load the deleted application.');

    // Ensure recruit_application_delete_multiple() can delete multiple applications.
    $return = recruit_application_delete_multiple(array_keys($saved_applications));
    $this->assertTrue($return, 'recruit_application_delete_multiple() returned TRUE when deleting a application.');
    $deleted_applications_load = recruit_application_load_multiple(array_keys($saved_applications), array(), TRUE);
    $this->assertFalse($deleted_application_load, 'recruit_application_load_multiple() could not load the deleted applications.');
  }

  /**
   * Test application Token replacement.
   */
  function testRecruitApplicationTokens() {
    $application = recruit_application_new('application');
    $application->application_ref = $this->randomName(10);
    $application->title = $this->randomName(10);
    $application->uid = 1;
    $application = recruit_application_save($application);

    $this->assertEqual(token_replace('[application:application-id]', array('application' => $application)), $application->application_id, '[application:application-id] was replaced with the application ID.');
    $this->assertEqual(token_replace('[application:application-ref]', array('application' => $application)), $application->application_ref, '[application:application-ref] was replaced with the application reference.');
    $this->assertEqual(token_replace('[application:type]', array('application' => $application)), recruit_application_type_get_name($application->type), '[application:type] was replaced with the application type.');
    $this->assertEqual(token_replace('[application:title]', array('application' => $application)), $application->title, '[application:title] was replaced with the title.');
    $this->assertNotIdentical(strpos(token_replace('[application:edit-url]', array('application' => $application)), url('admin/recruit/applications/' . $application->application_id . '/edit')), FALSE, '[application:edit-url] was replaced with the edit URL.');
    $this->assertEqual(token_replace('[application:created]', array('application' => $application)), format_date($application->created, 'medium'), '[application:created] was replaced with the created date.');
  }
}

/**
 * Test the Rules and Entity Metadata integration.
 */
class RecruitApplicationRulesTestCase extends DrupalWebTestCase {

  public static function getInfo() {
    return array(
      'name' => 'Recruit application rules integration',
      'description' => 'Tests the recruit application rules integration',
      'group' => 'Recruit',
    );
  }

  function setUp() {
    parent::setUp('recruit_application', 'rules');
  }

  /**
   * Calculates the output of t() given an array of placeholders to replace.
   */
  static function t($text, $strings) {
    $placeholders = array();
    foreach ($strings as $string) {
      $placeholders['%' . $string] = drupal_placeholder(array('text' => $string));
    }
    return strtr($text, $placeholders);
  }

  /**
   * Tests rules CRUD actions for applications.
   */

  function testRulesCRUD() {
    // Test creation.
    $action = rules_action('entity_create', array(
      'type' => 'recruit_application',
      'param_type' => 'application',
      'param_application-ref' => 'foo',
      'param_title' => 'bar',
      'param_creator' => $GLOBALS['user'],
    ));
    // Test running access() and execute.
    $action->access();
    $action->execute();

    $text = RulesLog::logger()->render();
    $pos = strpos($text, self::t('Added the provided variable %entity_created of type %recruit_application', array('entity_created', 'recruit_application')));
    $pos = ($pos !== FALSE) ? strpos($text, self::t('Saved %entity_created of type %recruit_application.', array('entity_created', 'recruit_application')), $pos) : FALSE;
    $this->assertTrue($pos !== FALSE, 'application has been created and saved.');

    $application = recruit_application_new('application');
    recruit_application_save($application);
    $rule = rule();
    $rule->action('entity_fetch', array('type' => 'recruit_application', 'id' => $application->application_id, 'entity_fetched:var' => 'application'));
    $rule->action('entity_save', array('data:select' => 'application', 'immediate' => TRUE));
    $rule->action('entity_delete', array('data:select' => 'application'));
    // Test running access and integrtiy check + execute.
    $rule->access();
    $rule->integrityCheck()->execute();
    $text = RulesLog::logger()->render();
    $pos = strpos($text, RulesTestCase::t('Evaluating the action %entity_fetch.', array('entity_fetch')));
    $pos = ($pos !== FALSE) ? strpos($text, self::t('Added the provided variable %application of type %recruit_application', array('application', 'recruit_application')), $pos) : FALSE;
    $pos = ($pos !== FALSE) ? strpos($text, self::t('Saved %application of type %recruit_application.', array('application', 'recruit_application')), $pos) : FALSE;
    $pos = ($pos !== FALSE) ? strpos($text, self::t('Evaluating the action %entity_delete.', array('entity_delete')), $pos) : FALSE;
    $this->assertTrue($pos !== FALSE, 'application has been fetched, saved and deleted.');
    //debug(RulesLog::logger()->render());
    $this->assertFalse(recruit_application_load($application->application_id), 'application has been deleted.');
  }

  /**
   * Tests making use of application metadata.
   */
  function testApplicationPropertyInfo() {
    // Populate $values with all values that are setable. They will be set
    // with an metadata wrapper, so we also test setting that way.
    $values = array();
    $wrapper = entity_metadata_wrapper('recruit_application');
    foreach ($wrapper as $name => $child) {
      $info = $wrapper->$name->info();
      if (!empty($info['setter callback'])) {
        $info += array('type' => 'text');
        $values[$name] = $this->createValue($info['type'], $info);
      }
    }
    $values['type'] = 'application';
    $application = entity_metadata_entity_create('recruit_application', $values)->value();
    $this->assertTrue($application, "Created a application and set all setable values.");

    $wrapper = entity_metadata_wrapper('recruit_application', $application);
    foreach ($wrapper as $key => $child) {
      $this->assertValue($wrapper, $key);
    }
  }

  /**
   * Assert the value for the given property is returned.
   */
  protected function assertValue($wrapper, $key) {
    $this->assertTrue($wrapper->$key->value() !== NULL, check_plain($key) . ' property returned.');
    $info = $wrapper->$key->info();
    if (!empty($info['raw getter callback'])) {
      // Also test getting the raw value
      $this->assertTrue($wrapper->$key->raw() !== NULL, check_plain($key) . ' raw value returned.');
    }
  }

  /**
   * Creates a value for the given data type.
   */
  protected function createValue($type, $info) {
    if (!isset($this->node)) {
      // Create some entities to use the first time this runs.
      $this->node = $this->drupalCreateNode(array('type' => 'article'));
      $this->user = $this->drupalCreateUser();
    }

    if (isset($info['options list'])) {
      $options = array_keys($info['options list']());
      return entity_metadata_list_extract_type($type) ? array(reset($options)) : reset($options);
    }

    switch ($type) {
      case 'decimal':
      case 'integer':
      case 'duration':
        return 1;
      case 'date':
        return REQUEST_TIME;
      case 'boolean':
        return TRUE;
      case 'text':
        return drupal_strtolower($this->randomName(8));
      case 'text_formatted':
        return array('value' => $this->randomName(16));

      default:
        return $this->$type;
    }
  }

  /**
   * Tests making use of the application 'presave' event and loading the unchanged
   * application.
   */
  public function testApplicationEvent() {
    $rule = rules_reaction_rule();
    $rule->event('recruit_application_presave')
         ->condition('data_is', array('data:select' => 'application:type', 'value' => 'application'))
         ->condition(rules_condition('data_is', array('data:select' => 'application:application_ref', 'value:select' => 'application_unchanged:application_ref'))->negate())
         ->action('entity_delete', array('data:select' => 'application'));
    // Try running access and integrity checks.
    $rule->access();
    $rule->integrityCheck();
    // Save it.
    $rule->save('recruit_application_test1', 'recruit_application');

    // Force immediate cache clearing so we can test the rule *now*.
    rules_clear_cache(TRUE);

    // Create initial application.
    $application = recruit_application_new('application');
    $application->application_ref = 'foo';
    recruit_application_save($application);

    $this->assertTrue(recruit_application_load($application->application_id), 'Reaction rule not fired.');

    // Now update, so that the rule fires.
    $application->application_ref = 'bar';
    recruit_application_save($application);
    $this->assertFalse(recruit_application_load($application->application_id), 'Reaction rule fired.');
    RulesLog::logger()->checkLog();
  }

}