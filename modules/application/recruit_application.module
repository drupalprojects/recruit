<?php
// $Id$

/**
 * @file
 * Defines Recruit application entity.
 */

/**
 * Implements hook_menu().
 */
function recruit_application_menu() {
  $items = array();

  $items['recruit_application/autocomplete'] = array(
    'title' => 'recruit_application autocomplete',
    'page callback' => 'recruit_application_autocomplete',
    'access arguments' => array('access applications'),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implementation of hook_hook_info().
 */
function recruit_application_hook_info() {
  foreach (array('info') as $hook) {
    $hooks['recruit_application_' . $hook] = array(
      'group' => 'recruit_application',
    );
  }
  return $hooks;
}

/**
 * Returns an initialized application type object.
 */
function recruit_application_type_new() {
  return (object) array(
    'type' => '',
    'name' => '',
    'description' => '',
    'help' => '',
    'modified' => 0,
  );
}

/**
 * Implementation of hook_enable().
 */
function recruit_application_enable() {

  //Rebuild application types
  recruit_application_types_rebuild();
  
  //Rebuild menus
  menu_rebuild();

  //Clear all cache
  cache_clear_all();
}

/**
 * Returns an array of application type objects keyed by type.
 */
function recruit_application_types() {
  return _recruit_application_types_build()->types;
}

/**
 * Rebuilds all application types added via hook_recruit_application_info into the database
 */
function recruit_application_types_rebuild() {
  // Reset and load updated application types.
  drupal_static_reset('_recruit_application_types_build');

  foreach (recruit_application_types() as $type) {
    $existing = recruit_application_type_load($type->type);
    if (empty($existing)) {
      $type->is_new = TRUE;
    }
    recruit_application_type_save($type);
  }
}

/**
 * Implementation of hook_features_api().
 */
function recruit_application_features_api() {
  return array(
    'recruit_application_type' => array(
      'name' => t('application types'),
      'feature_source' => TRUE,
      'default_hook' => 'recruit_application_info',
      'file' => drupal_get_path('module', 'recruit_application') . '/includes/recruit_application.features.inc',
    ),
  );
}

/**
 * Saves a application type.
 *
 * This function will either insert a new application type if $application_type->is_new
 * is set or attempt to update an existing application type if it is not. It does
 * not currently support changing the machine-readable name of the application type,
 * nor is this possible through the form supplied by the application UI module.
 *
 * @param $application_type
 *   The application type object containing the basic properties as initialized in
 *     recruit_application_type_new().
 *
 * @return
 *   The return value of the call to drupal_write_record() to save the application
 *     type, either FALSE on failure or SAVED_NEW or SAVED_UPDATED indicating
 *     the type of query performed to save the application type.
 */
function recruit_application_type_save($application_type) {
  $op = drupal_write_record('recruit_application_type', $application_type, empty($application_type->is_new) ? 'type' : array());
  menu_rebuild();

  // If this is a new application type and the insert did not fail...
  if ($op !== FALSE && $op == SAVED_NEW) {
    // Notify the field API that a new bundle has been created.
    field_attach_create_bundle('recruit_application', $application_type->type);

    // Notify other modules that a new application type has been created.
    module_invoke_all('recruit_application_type_insert', $application_type);
  }
  else {
    // Notify other modules that an existing application type has been updated.
    module_invoke_all('recruit_application_type_update', $application_type);
  }

  // Clear the application type cache.
  drupal_static_reset('_recruit_application_types_build');

  return $op;
}

/**
 * Checks application access for various operations.
 *
 * @param $op
 *   The operation being performed. One of 'view', 'update', 'create' or
 *   'delete'.
 * @param $application
 *   Optionally a application to check access for or for the create operation the
 *   application type. If nothing is given access permissions for all applications are returned.
 * @param $account
 *   The user to check for. Leave it to NULL to check for the current user.
 */
function recruit_application_access($op, $application = NULL, $account = NULL) {
  global $user;
  $account = isset($account) ? $account : $user;

  if (user_access('administer applications', $account)) {
    return TRUE;
  }

  if ($op == 'view' && user_access('access applications', $account)) {
    return TRUE;
  }

  if (isset($application) && is_string($application) && $op == 'create' && user_access('create ' . $application . ' applications', $account)) {
    return TRUE;
  }

  if (isset($application) && ($op == 'update' || $op == 'delete')) {
    if (user_access('edit any ' . $application->type . ' application', $account)) {
      return TRUE;
    }

    // Others either don't have any access or must match the application uid.
    if ($account->uid && user_access('edit own ' . $application->type . ' applications', $account) && $application->uid == $account->uid) {
      return TRUE;
    }
  }

  return FALSE;
}

/**
 * Returns an initialized application object.
 *
 * @param $type
 *   The machine-readable type of the application.
 *
 * @return
 *   A application object with all default fields initialized.
 */
function recruit_application_new($type = '') {
  return entity_get_controller('recruit_application')->create($type);
}

/**
 * Implements hook_views_api().
 */
function recruit_application_views_api() {
  return array(
    'api' => 2,
    'path' => drupal_get_path('module', 'recruit_application') . '/includes/views',
  );
}

/**
 * Implements hook_permission().
 */
function recruit_application_permission() {
  $permissions = array(
    'administer applications' => array(
      'title' => t('Administer applications'),
      'description' => t('Allows users to perform any action on applications of any type.'),
      'restrict access' => TRUE,
    ),
    'administer application types' => array(
      'title' => t('Administer application types'),
      'description' => t('Allows users to add application types and configure their fields.'),
      'restrict access' => TRUE,
    ),
    'access applications' => array(
      'title' => t('Access applications'),
      'description' => t('Allows users to view lists of applications in the Recruiter admin and reference lists.'),
    ),
  );

  // Add application type specific permissions. Note that users with administer
  // applications permission should have access to do anything the permissions below
  // grant a user to do.
  foreach (recruit_application_type_get_name() as $type => $name) {
    $permissions['create ' . $type . ' applications'] = array(
      'title' => t('Create %type applications', array('%type' => $name)),
    );
    $permissions['edit any ' . $type . ' application'] = array(
      'title' => t('Edit or delete any %type application', array('%type' => $name)),
    );
    $permissions['edit own ' . $type . ' applications'] = array(
      'title' => t('Edit or delete own %type applications', array('%type' => $name)),
    );
  }

  return $permissions;
}

/**
 * Builds and returns the list of available application types similar to the concept used
 * for node types
 *
 * The list of types is built by invoking hook_recrut_application_info() on all modules and
 * comparing this information with the application types in the {recruit_application_type} table.
 * These two information sources are not synchronized during module installation
 * until recruit_application_types_rebuild() is called.
 *
 * @return
 *   Associative array with two components:
 *   - names: Associative array of the names of application types, keyed by the type.
 *   - types: Associative array of recruit application type objects, keyed by the type.
 *   Both of these arrays will include new types that have been defined by
 *   hook_recruit_application_info() implementations but not yet saved in the {recruit_application_type}
 *   table.
 */
function _recruit_application_types_build() {
  // First check the static cache for a application types array.
  #$application_types = &drupal_static(__FUNCTION__);
  $application_types = '';
  if (is_object($application_types)) {
    return $application_types;
  }
  $application_types = (object)array('types' => array(), 'names' => array());

  // Build application_types from modules that implement recruit_application_info().
  $module_application_types = module_invoke_all('recruit_application_info');
  if (count($module_application_types) > 0) {
    foreach ($module_application_types as $type) {
      $application_types->types[$type->type] = $type;
      $application_types->names[$type->type] = $type->name;
    }
  }

  // Get application types from DB and add them to the application types array defined by hook_recruit_application_info()
  // if they don't exist yet. application types provided by the hook will override/update application types in the DB.
  // However, the machine-readable name (type) will stay the same, only metadata is affected.
  $db_application_types = db_query('SELECT * FROM {recruit_application_type}')->fetchAllAssoc('type');
  foreach ($db_application_types as $type_object) {
    
    // TODO: If application types can be disabled in the future, check for those not used by any module anymore
    // and mark them as disabled. These application types will then be deleted next time recruit_application_types_rebuild()
    // is called
    if (!isset($application_types->types[$type_object->type]) || $type_object->modified) {
      $application_types->types[$type_object->type] = $type_object;
      $application_types->names[$type_object->type] = $type_object->name;
    }
  }

  asort($application_types->names);

  return $application_types;
}

/**
 * Returns the human readable name of any or all application types.
 *
 * @param $type
 *   Optional parameter specifying the type whose name to return.
 *
 * @return
 *   Either an array of all application type names keyed by the machine name or a
 *     string containing the human readable name for the specified type. If a
 *     type is specified that does not exist, this function returns FALSE.
 */
function recruit_application_type_get_name($type = NULL) {

  $type = _recruit_application_extract_type($type);
  $types = _recruit_application_types_build()->names;

  if ($type != NULL && !isset($types[$type])) {
    return FALSE;
  }
  return isset($types[$type]) ? $types[$type] : $types;

}

/**
 * Extract the type name.
 *
 * @param $application type
 *   Either a string or object, containing the application type information.
 *
 * @return
 *   application type of the passed in data.
 */
function _recruit_application_extract_type($type) {
  return is_object($type) ? $type->type : $type;
}

/**
 * Implements hook_entity_info().
 */
function recruit_application_entity_info() {
  $return = array(
    'recruit_application' => array(
      'label' => t('application'),
      'controller class' => 'RecruitApplicationEntityController',
      'base table' => 'recruit_application',
      'fieldable' => TRUE,
      'entity keys' => array(
        'id' => 'application_id',
        'bundle' => 'type',
      ),
      'bundle keys' => array(
        'bundle' => 'type',
      ),
      'bundles' => array(),
      'load hook' => 'recruit_application_load',
      'view modes' => array(
        'admin' => array(
          'label' => t('Admin display'),
          'custom settings' => FALSE,
        ),
        'teaser' => array(
          'label' => t('application: Teaser'),
          'custom settings' => TRUE,
        ),
        'full' => array(
          'label' => t('application: Full content'),
          'custom settings' => FALSE,
        ),
        ' rss' => array(
          'label' => t('application: RSS'),
          'custom settings' => FALSE,
        ),
      ),
      'creation callback' => '_recruit_application_create',
      'save callback' => 'recruit_application_save',
      'deletion callback' => 'recruit_application_delete',
      'access callback' => 'recruit_application_access',
    ),
  );

  foreach (recruit_application_type_get_name() as $type => $name) {
    $return['recruit_application']['bundles'][$type] = array(
      'label' => $name,
    );
  }

  return $return;
}

/**
 * Implements hook_field_extra_fields().
 */
function recruit_application_field_extra_fields() {
  $extra = array();

  foreach (recruit_application_types() as $type => $application_type) {
    $extra['recruit_application'][$type] = array(
      'form' => array(
        'application_ref' => array(
          'label' => 'application Reference',
          'description' => t('application module application reference form element'),
          'weight' => -10,
        ),
        'first_name' => array(
          'label' => 'First name',
          'description' => t('application module first name form element'),
          'weight' => -5,
        ),
        'last_name' => array(
          'label' => 'Last name',
          'description' => t('application module last name form element'),
          'weight' => -5,
        ),
        'status' => array(
          'label' => 'Status',
          'description' => t('application module status form element'),
          'weight' => 35,
        ),
      ),
      'display' => array(
        'application_ref' => array(
          'label' => 'application Reference',
          'description' => t('The human readable identifier of the application'),
          'weight' => -10,
        ),
        'first_name' => array(
          'label' => 'First name',
          'description' => t('Full application first name'),
          'weight' => -5,
        ),
        'last_name' => array(
          'label' => 'Last name',
          'description' => t('Full application last name'),
          'weight' => -4,
        ),
      ),
    );
  }

  return $extra;
}

/**
 * Loads a application by ID.
 */
function recruit_application_load($application_id) {
  $applications = recruit_application_load_multiple(array($application_id), array());
  return $applications ? reset($applications) : FALSE;
}

/**
 * Loads multiple applications by ID or based on a set of matching conditions.
 *
 * @see entity_load()
 *
 * @param $applications_ids
 *   An array of application IDs.
 * @param $conditions
 *   An array of conditions on the {recruit_application} table in the form
 *     'field' => $value.
 * @param $reset
 *   Whether to reset the internal application loading cache.
 *
 * @return
 *   An array of application objects indexed by application_id.
 */
function recruit_application_load_multiple($applications_ids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load('recruit_application', $applications_ids, $conditions, $reset);
}

/**
 * Creation callback for the Entity Metadata module.
 */
function _recruit_application_create($values = array()) {
  // Create a new application of the specified type.
  $application = recruit_application_new($values['type']);
  unset($values['type']);

  $wrapper = entity_metadata_wrapper('recruit_application', $application);

  foreach ($values as $name => $value) {
    $wrapper->$name->set($value);
  }

  return $wrapper;
}

/**
 * Saves a application.
 *
 * @param $application
 *   The full application object to save.
 *
 * @return
 *   TRUE on success, FALSE otherwise.
 */
function recruit_application_save($application) {
  return entity_get_controller('recruit_application')->save($application);
}

/**
 * Deletes a application by ID.
 *
 * @param $application_id
 *   The ID of the application to delete.
 *
 * @return
 *   TRUE on success, FALSE otherwise.
 */
function recruit_application_delete($application_id) {
  return recruit_application_delete_multiple(array($application_id));
}

/**
 * Deletes multiple applications by ID.
 *
 * @param $application_ids
 *   An array of application IDs to delete.
 *
 * @return
 *   TRUE on success, FALSE otherwise.
 */
function recruit_application_delete_multiple($application_ids) {
  return entity_get_controller('recruit_application')->delete($application_ids);
}

/**
 * Callback for getting application properties.
 * @see recruit_application_entity_property_info()
 */
function recruit_application_get_properties($application, array $options, $name) {
  switch ($name) {
    case 'creator':
      return $application->uid;
    case 'edit-url':
      return url('admin/recruit/applications/' . $application->application_id . '/edit', $options);
  }
}

/**
 * Callback for setting application properties.
 * @see recruit_application_entity_property_info()
 */
function recruit_application_set_properties($application, $name, $value) {
  if ($name == 'creator') {
    $application->uid = $value;
  }
}

/**
 * Validates a application Reference string for acceptable characters.
 *
 * @param $application_ref
 *   The application Reference string to validate.
 *
 * @return
 *   TRUE or FALSE indicating whether or not the application Reference contains valid characters.
 */
function recruit_application_validate_application_ref_characters($application_ref) {
  return preg_match('!^[A-Za-z0-9_-]+$!', $application_ref);
}

/**
 * Checks to see if a given application reference already exists for another application.
 *
 * @param $application_ref
 *   The string to match against existing application references.
 * @param $application_id
 *   The ID of the application the application reference is for; an empty value represents the application reference is
 *     meant for a new application.
 *
 * @return
 *   TRUE or FALSE indicating whether or not the application reference exists for another application.
 */
function recruit_application_validate_application_ref_unique($application_ref, $application_id) {
  // Look for an ID of a application matching the supplied application_ref.
  if ($match_id = db_query('SELECT application_id FROM {recruit_application} WHERE application_ref = :application_ref', array(':application_ref' => $application_ref))->fetchField()) {
    // If this application_ref is supposed to be for a new application or a application other than
    // the one that matched...
    if (empty($application_id) || $match_id != $application_id) {
      return FALSE;
    }
  }

  return TRUE;
}

/**
 * Checks to see if a given application type already exists.
 *
 * @param $type
 *   The string to match against existing types.
 *
 * @return
 *   TRUE or FALSE indicating whether or not the application type exists.
 */
function recruit_application_type_validate_type_unique($type) {
  // Look for a match of the type.
  if ($match_id = db_query('SELECT type FROM {recruit_application_type} WHERE type = :type', array(':type' => $type))->fetchField()) {
    return FALSE;
  }

  return TRUE;
}

/**
 * Loads a application type.
 *
 * @param $type
 *   The machine-readable name of the application type.
 */
function recruit_application_type_load($type) {
  $type = strtr($type, array('-' => '_'));
  $application_types = db_query('SELECT * FROM {recruit_application_type} WHERE type = :type', array(':type' => $type))->fetchObject();

  module_invoke_all('recruit_application_type_load', $application_types);

  return $application_types;
}

/**
 * Deletes a application type.
 *
 * @param $type
 *   The machine-readable name of the application type.
 */
function recruit_application_type_delete($type) {
  $application_type = recruit_application_type_load($type);

  db_delete('recruit_application_type')
    ->condition('type', $type)
    ->execute();

  menu_rebuild();

  // Clear the application type cache.
  drupal_static_reset('_recruit_application_types_build');

  // Notify the field API that this bundle has been destroyed.
  field_attach_delete_bundle('recruit_application', $type);

  // Notify other modules that this application type has been deleted.
  module_invoke_all('recruit_application_type_delete', $application_type);
}

/**
 * Title callback: return the human-readable application type name.
 */
function recruit_application_type_title($application_type) {
  return $application_type->name;
}

/**
 * Returns a path argument from a application type.
 */
function recruit_application_type_to_arg($type) {
  return $type;
}

/**
 * Handler to load the unchanged application variable for rules.
 * @see recruit_application_rules_variables().
 */
function recruit_application_rules_var_unchanged($application) {
  $unchanged = drupal_static('recruit_application_unchanged');
  if (isset($application->application_id) && isset($unchanged[$application->application_id])) {
    return $unchanged[$application->application_id];
  }
}

/**
 * Resets the cached list of application types.
 */
function recruit_application_types_reset() {
  drupal_static_reset('recruit_application_types');
}

/**
 * Loads a application by application reference.
 */
function recruit_application_load_by_application_ref($application_ref) {
  $applications = recruit_application_load_multiple(array(), array('application_ref' => $application_ref));
  return $applications ? reset($applications) : FALSE;
}

/**
 * Implements hook_pathauto().
 */
function recruit_application_pathauto($op) {
  switch ($op) {
    case 'settings':
      $settings = array();
      $settings['module'] = 'recruit_application';
      $settings['token_type'] = 'application';
      $settings['groupheader'] = t('application paths');
      $settings['patterndescr'] = t('Default path pattern (applies to all application types with blank patterns below)');
      $settings['patterndefault'] = 'application/[application:title]';
      $settings['batch_update_callback'] = 'recruit_application_pathauto_bulk_update_batch_process';
      #$settings['batch_file'] = drupal_get_path('module', 'pathauto') . '/pathauto.pathauto.inc';

      $languages = array();
      if (module_exists('locale')) {
        $languages = array(LANGUAGE_NONE => t('language neutral')) + locale_language_list('name');
      }

      foreach (recruit_application_types() as $application_type) {
        if (count($languages) && variable_get('language_content_type_' . $application_type->type, 0)) {
          $settings['patternitems'][$application_type->type] = t('Default path pattern for @node_type (applies to all @application_type node types with blank patterns below)', array('@application_type' => $application_type->name));
          foreach ($languages as $lang_code => $lang_name) {
            $settings['patternitems'][$application_type->type . '_' . $lang_code] = t('Pattern for all @language @application_type paths', array('@application_type' => $application_type->name, '@language' => $lang_name));
          }
        }
        else {
          $settings['patternitems'][$application_type->type] = t('Pattern for all @application_type paths', array('@application_type' => $application_type->name));
        }
      }


      return (object) $settings;
    default:
      break;
  }
}

/**
 * Implements hook_recruit_application_insert().
 */
function recruit_application_recruit_application_insert($application) {
  #if (!isset($node->path['pathauto_perform_alias']) || !empty($node->path['pathauto_perform_alias'])) {
  if (module_exists('pathauto')) {
    recruit_application_application_update_alias($application, 'insert');
  }
  #}
}

/**
 * Implements hook_recruit_application_update().
 */
function recruit_application_recruit_application_update($application) {
  #if (!isset($node->path['pathauto_perform_alias']) || !empty($node->path['pathauto_perform_alias'])) {
  if (module_exists('pathauto')) {
    recruit_application_application_update_alias($application, 'update');
  }
  #dsm($application);
  
  #}
}

/**
 * Implements hook_recruit_application_delete().
 */
function recruit_application_recruit_application_delete($application) {
  if (module_exists('pathauto')) {
    //Get application uri.
    $uri = entity_uri('recruit_application', $application);
    pathauto_entity_path_delete_all('recruit_application', $application, $uri['path']);
  }
}

/**
 * Update the URL aliases for an individual application.
 *
 * @param $application
 *   A application object.
 * @param $op
 *   Operation being performed on the application ('insert', 'update' or 'bulkupdate').
 * @param $options
 *   An optional array of additional options.
 */
function recruit_application_application_update_alias(stdClass $application, $op, array $options = array()) {
  // Skip processing if the term has no pattern.
  $language = isset($application->language) ? $application->language : LANGUAGE_NONE;
  if (!pathauto_pattern_load_by_entity('recruit_application', $application->type, $language)) {
    return;
  }

  module_load_include('inc', 'pathauto');
  $uri = entity_uri('recruit_application', $application);

  pathauto_create_alias('recruit_application', $op, $uri['path'], array('application' => $application), $application->type, $language);
}

/**
 * Implements hook_path_alias_types().
 *
 * Used primarily by the bulk delete form.
 */
function recruit_application_path_alias_types() {
  $objects['admin/recruit/applications/'] = t('applications');
  return $objects;
}

/**
 * Batch processing callback; Generate aliases for applications.
 */
function recruit_application_pathauto_bulk_update_batch_process(&$context) {
  if (!isset($context['sandbox']['current'])) {
    $context['sandbox']['count'] = 0;
    $context['sandbox']['current'] = 0;
  }

  $query = db_select('recruit_application', 'j');
  $concat = _pathauto_sql_concat("'admin/recruit/applications/'", 'j.application_id');
  $query->leftJoin('url_alias', 'ua', "$concat = ua.source");
  $query->addField('j', 'application_id');
  $query->isNull('ua.source');
  $query->condition('j.application_id', $context['sandbox']['current'], '>');
  $query->orderBy('j.application_id');
  $query->addTag('pathauto_bulk_update');
  $query->addMetaData('entity', 'recruit_application');

  // Get the total amount of items to process.
  if (!isset($context['sandbox']['total'])) {
    $context['sandbox']['total'] = $query->countQuery()->execute()->fetchField();

    // If there are no nodes to update, the stop immediately.
    if (!$context['sandbox']['total']) {
      $context['finished'] = 1;
      return;
    }
  }

  $query->range(0, 25);
  $application_ids = $query->execute()->fetchCol();

  recruit_application_application_update_alias_multiple($application_ids, 'bulkupdate');
  $context['sandbox']['count'] += count($application_ids);
  $context['sandbox']['current'] = max($application_ids);
  $context['message'] = t('Updated alias for node @application_id.', array('@application_id' => end($application_ids)));

  if ($context['sandbox']['count'] != $context['sandbox']['total']) {
    $context['finished'] = $context['sandbox']['count'] / $context['sandbox']['total'];
  }
}

/**
 * Update the URL aliases for multiple applications.
 *
 * @param $application_ids
 *   An array of application IDs.
 * @param $op
 *   Operation being performed on the applications ('insert', 'update' or
 *   'bulkupdate').
 * @param $options
 *   An optional array of additional options.
 */
function recruit_application_application_update_alias_multiple(array $application_ids, $op, array $options = array()) {
  $options += array('message' => FALSE);

  $applications = recruit_application_load_multiple($application_ids);
  foreach ($applications as $application) {
    recruit_application_application_update_alias($application, $op, $options);
  }

  if (!empty($options['message'])) {
    drupal_set_message(format_plural(count($application_ids), 'Updated URL alias for 1 application.', 'Updated URL aliases for @count applications.'));
  }
}

/**
 * Fetches an array of all applications matching the given parameters.
 *
 * This info is used in various places (allowed values, autocomplete results,
 * input validation...). Some of them only need the application_ids, others
 * application_id + titles, others yet application_id + titles + rendered row (for
 * display in widgets).
 *
 * The array we return contains all the potentially needed information,
 * and lets calling functions use the parts they actually need.
 *
 * @param $field
 *   The field description.
 * @param $string
 *   Optional string to filter application_refs and titles on (used by autocomplete).
 * @param $match
 *   Operator to match filtered application_refs and titles against, can be any of:
 *   'contains', 'equals', 'starts_with'
 * @param $ids
 *   Optional application ids to lookup (used when $string and $match arguments are
 *   not given).
 * @param $limit
 *   If non-zero, limit the size of the result set.
 *
 * @return
 *   An array of valid applications in the form:
 *   array(
 *     application_id => array(
 *       'application_ref' => The application ref,
 *       'title' => The application title,
 *       'rendered' => The text to display in widgets (can be HTML)
 *     ),
 *     ...
 *   )
 */
function recruit_application_match_applications($field, $string = '', $match = 'contains', $ids = array(), $limit = NULL) {
  $results = &drupal_static(__FUNCTION__, array());

  // Create unique id for static cache.
  $cid = implode(':', array(
    $field['field_name'],
    $match,
    ($string !== '' ? $string : implode('-', $ids)),
    $limit,
  ));

  if (!isset($results[$cid])) {
    $matches = _recruit_application_match_applications_standard($field, $string, $match, $ids, $limit);

    // Store the results.
    $results[$cid] = !empty($matches) ? $matches : array();
  }

  return $results[$cid];
}

/**
 * Helper function for recruit_application_match_applications().
 *
 * Returns an array of applications matching the specific parameters.
 */
function _recruit_application_match_applications_standard($field, $string = '', $match = 'contains', $ids = array(), $limit = NULL) {
  // Build the query object with the necessary fields.
  $query = db_select('recruit_application', 'rj');
  $application_id_alias = $query->addField('rj', 'application_id');
  $application_application_ref_alias = $query->addField('rj', 'application_ref');
  $application_title_alias = $query->addField('rj', 'title');
  $application_type_alias = $query->addField('rj', 'type');

  // Add a condition to the query to filter by matching application types.
  if (!empty($field['settings']) && is_array($field['settings']['referenceable_types']) && !empty($field['settings']['referenceable_types'])) {
    $types = array_diff(array_values($field['settings']['referenceable_types']), array(0, NULL));

    // Only filter by type if some types have been specified.
    if (!empty($types)) {
      $query->condition('rj.type', $types, 'IN');
    }
  }

  if ($string !== '') {
    $args = array();

    // Build a where clause matching on either the application ref or title.
    switch ($match) {
      case 'contains':
        $where = '(rj.application_ref LIKE :application_ref_match OR rj.title LIKE :title_match)';
        $args['application_ref_match'] = '%' . $string . '%';
        $args['title_match'] = '%' . $string . '%';
        break;

      case 'starts_with':
        $where = '(rj.application_ref LIKE :application_ref_match OR rj.title LIKE :title_match)';
        $args['application_ref_match'] = $string . '%';
        $args['title_match'] = $string . '%';
        break;

      case 'equals':
      default:
        $where = '(rj.application_ref = :application_ref_match OR rj.title = :title_match)';
        $args['application_ref_match'] = $string;
        $args['title_match'] = $string;
        break;
    }

    $query->where($where, $args);
  }
  elseif ($ids) {
    // Otherwise add a application_id specific condition if specified.
    $query->condition($application_id_alias, $ids, 'IN', $ids);
  }

  // Order the results by application_ref, title, and then application type.
  $query
    ->orderBy($application_application_ref_alias)
    ->orderBy($application_title_alias)
    ->orderBy($application_type_alias);

  // Add a limit if specified.
  if ($limit) {
    $query->range(0, $limit);
  }

  // Execute the query and build the results array.
  $result = $query->execute();

  $matches = array();

  foreach ($result->fetchAll() as $application) {
    $matches[$application->application_id] = array(
      'application_ref' => $application->application_ref,
      'type' => $application->type,
      'first_name' => $application->first_name,
      'rendered' => t('@application_ref: @title', array('@application_ref' => $application->application_ref, '@title' => $application->first_name)),
    );
  }

  return $matches;
}

/**
 * Returns output for application autocompletes.
 *
 * The values returned will be keyed by application_ref and appear as such in the textfield,
 * even though the preview in the autocomplete list shows "application_ref: Title".
 */
function recruit_application_autocomplete($field_name, $string = '') {
  $field = field_info_field($field_name);
  $matches = array();

  // The user enters a comma-separated list of tags. We only autocomplete the last tag.
  $tags_typed = drupal_explode_tags($string);
  $tag_last = drupal_strtolower(array_pop($tags_typed));

  if (!empty($tag_last)) {
    $prefix = count($tags_typed) ? implode(', ', $tags_typed) . ', ' : '';

    // Determine the type of autocomplete match to use when searching for applications.
    $match = isset($field['widget']['autocomplete_match']) ? $field['widget']['autocomplete_match'] : 'contains';

    // Get an array of matching applications.
    $applications = recruit_application_match_applications($field, $tag_last, $match, array(), 10);

    // Loop through the applications and convert them into autocomplete output.
    foreach ($applications as $application_id => $data) {
      // Add a class wrapper for a few required CSS overrides.
      $matches[$prefix . $data['application_ref']] = '<div class="reference-autocomplete">' . $data['rendered'] . '</div>';
    }
  }

  drupal_json_output($matches);
}
